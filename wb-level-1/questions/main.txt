1. (https://stackoverflow.com/questions/1760757/how-to-efficiently-concatenate-strings-in-go)
 Сравним конкатинацию суммированием и буфером (в тестовой выборке 50 строк):
BenchmarkStringSum-8                      360841              3373 ns/op            5176 B/op         49 allocs/op
BenchmarkStringBufferConcat-8            1845566               624 ns/op             688 B/op          4 allocs/op
BenchmarkStringCopyConcat-8              3397803               363 ns/op             384 B/op          2 allocs/op

 Таким образом конкатенация с использованием буфера сильно эффективнее чем конкатенация суммой, конкатенация функцией
copy() еще более эффективна, но для ее использования нам нужно заранее знать или посчитать общую длину строк.

2.
 Интерфейс - это совокупность методов и правил взаимодействия элементов системы.
 В Go не нужно явно указывать, что какойто тип реализует интерфейс, достаточно чтобы он реализвывал все его методы.
 Переменную можно обьявить интерфейсом (var v interface{...}), тогда ей можно присвоить значение любого типа
реализующего этот интерфейс, в таком случае все функции данного типа не реализованные в интерфейсе будут не доступны.
 Из переменной обьявленной интерфейсом можно попытаться извлечь ее тип с помощью конструкции:
 w,ok := v.(Type)  - (https://tour.golang.org/methods/15)
 Интерфейс может быть аргументом функции.
 В интерфейсе могут отсутствовать методы, тогда этот интерфейс называется пустым интерфейсом.
Пустой интерфейс может принимать значения любого типа и обычно используется когда мы не знаем
тип переменных с которыми работаем. - (https://tour.golang.org/methods/14)

3. (https://qna.habr.com/q/787559)
 RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например,
стандартный тип map.
 Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах
будут ждать, пока вы не отпустите мьютекс через .Unlock().
 Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются,
вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди
могут забирать мьютекс на себя.
 Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

4.
При записи в небуферизированный канал он блокирует текущую горутину пока ктото не считает из него значение.
При записи в буферизированный канал он будет блокировать горутину только в том случае если его буфер заполнен.

5. (https://stackoverflow.com/questions/47544156/what-uses-a-type-with-empty-struct-has-in-go#:~:text=2%20Answers&text=Empty%20struct%20struct%7B%7D%20is,size%20is%20literally%200%20bytes.)
 1. Размер пустой структуры равен 0 байт.
unsafe.Sizeof(struct{}{})    // 0
 2. Таким образом слайс пустых структур любого размера будет очень маленьким(также и для каналов), так как будет
 увеличиваться только значение len массива при этом сами значения храниться не будут.
 BenchmarkEmptyStructSlice100-8           3090174               369 ns/op               0 B/op          0 allocs/op
 BenchmarkEmptyStructSlice1000-8           321240              3614 ns/op               0 B/op          0 allocs/op
 BenchmarkEmptyStructSlice10000-8           33283             34742 ns/op               0 B/op          0 allocs/op
 3. Все указатели на пустую структуру указывают на одно и тоже специальное место в памяти.
 4. Можно использовать в каналах уведомляющих о совершении какого либо события. Так как в таком случае при поступлении
в канал значения не будет выделяться и заниматься место(это лучше использования bool т.к. bool занимает 1 байт).
 5. Можно использовать в качестве контейнера для функций нулевого обьема (например, для реализации интерфейса
для тестирования).
 6. Можно реализовать set (набор уникальных значений) с помощью map[string]struct{} , то есть ключи уникальные,
а значения пустые.

6. (https://stackoverflow.com/questions/29164375/correct-way-to-initialize-empty-slice)
 По функциональности nil slice и slice нулевого обьема эквивалентны. Они имеют нулевой обьем и могут быть
увеличены функцией append().
var a []int    // стоит использовать когда не будет случаев в которых такой подход может вызвать проблемы.
a := []int{}   // стоит использовать если нужно парсить слайс, например, в json.

7.
Создать перегрузку нельзя, но есть встроенные функции с перегрузкой, например, make([]int)/make([]int,l)/make([]int,l,c)

8. (https://blog.golang.org/maps#TOC_7.)
При обходе циклом(for k, v := range m{...}) элементы будут выведены в случайном порядке.

9. (https://programming.vip/docs/the-difference-between-new-and-make-in-golang.html#:~:text=In%20golang%2C%20both%20make%20and,make%20allocates%20and%20initializes%20memory.)
new() - алоцирует память и возвращает указатель заданного типа с нулевым значением.
make() - алоцирует и инициализирует значение переданного типа (тип передается первым аргументом и может быть только
slice, map или chan) и возвращает его значение с параметрами зависящими от переданного типа.
slice: make([]int, a) - возвращает слайс с len=cap=a
       make([]int, a, b) - возвращает слайс с len=a cap=b
map:   make(map[int]int, a) - возвращает map с зараннее выделенным местом для хранения a элементов.
       make(map[int]int) - в данном случае начальное количество выделенного места автоматически
       задается маленьким значением.
chan:  make(chan int, a) - возвращает буферезированный канал с обьемом буфера равным а (если a=0,
       то канал не буферезированный).

10. (https://www.golangprograms.com/go-language/slices-in-golang-programming.html)
slice:
var intSlice []int                    // len=cap=0 (значение nil, но можно использовать append)
var intSlice = make([]int, 10)        // len=cap=10
var strSlice = make([]string, 10, 20) // len=10 cap=20
var intSlice = []int{1, 2, 3, 4, 5}   // len=cap=5
var intSlice = new([20]int)[0:10]     // len=10 cap=20
var intArray [20]int                  //
intSlice := intArray[0:10]            // len=10 cap=20

map:
var intMap map[int]int                // значение nil для использования необходимо присвоить инициализированное значение
var intMap = new(map[int]int)         // значение nil для использования необходимо присвоить инициализированное значение
var intMap = map[int]int{}
var intMap = make(map[int]int)
var intMap = make(map[int]int, 10)